---
title: 被忽略的 TCP 基础知识
date: 2016-06-28 08:42:16
tags:
---

前段时间在做使用 TCP 直接通信的项目，iOS 中 TCP 的封装库 CocoaAsyncSocket 已经相当知名，能帮助实现绝大多数的功能。然而作为程序员保持好奇心很重要，虽然在大学里上过相关的课程，有一定的实践经验之后再「回顾」也是颇有收获。主要包括三个部分：

这篇文并不打算记录 TCP 的三次握手和四次挥手，这应该是程序员看的最多的 TCP 相关的基础了，本文大纲：

1. 滑动窗口
2. 超时重传时间选择
3. 握手缺陷

<!--more-->


## 滑动窗口

TCP 的发送方和接收方都各自维护着一个窗口，对窗口的控制是 TCP 数据传输的精髓所在。先来看看发送窗口和接收窗口的作用，假定发送方为 A， 接收方为 B：

- 发送窗口：在没有收到 B 的确认情况下，A 可以连续的把窗口内的数据都发送出去。但是已经发送的数据，如果没有收到确认之前都必须暂时保存，以便超时重传。

- 接收窗口：到达接收方的数据可能不是按顺序到达的，如果前面有未收到的数据字节，收到这个字节之后的数据就会被临时存放在接受窗口中。 B 只能按照顺序的对收到数据中的最高序号发确认消息，因此即使提前收到了后面的数据，B 给出的仍旧是前面未收到数据的最小编号作为确认号发给接收端。


在窗口设定时 A 的发送窗口大小不能超过 B 的接受窗口大小。虽然我们一般会将其设置为一样大，但是同一时刻，A 的发送窗口并不总是等于接受窗口的大小。会受到网络拥塞的影响。

对于不按顺序到达的数据的处理，TCP 标准并无明确的规定。如果接受方把不按顺序到达的数据一律丢弃，那么接受窗口的管理就会比较简单，但这样做对网络资源的利用率会降低。因此 TCP 通常对不按序到达的数据存放到临时的窗口，等到字节流中缺少的字节收到后再上交应用层。

对不按顺序到达的数据做标记有一定的困难，因为在 TCP 报文的首部标准中并没有定义保存其他报文的边界的字段，所以接收放一般会在首部40字节的「选项」字段里面写入提前收到的报文的边界信息，并标识 SACK 为1。不过由于选项字段的长度有限，最多也只能保存 40 / (4*2) = 4 个报文的边界信息(序号为4个字节，一段报文有左右两个边界)。当有报文滞后四个字节以上，那之后提前收到的报文也就只能重传了。

TCP 还要求接收方必须有累计确认的功能，而不是收到一个报文就确认。这样可以减少传输的开销。接收方还可以在自己有数据发送的时候捎带上确认信息。但是接收方不会过分的推迟发送的确认，否者会导致超时造成不必要的重传。捎带确认的情况并不会经常发生，大多数应用程序都不会同时在两个方向上发送数据。在流量控制一节还会具体的介绍。


## 超时重传时间的选择
要设置超时计时器的重传时间，首先需要知道 TCP 从发送报文到收到报文往返的时间，
它被被称为 **RTT**。当然我们不可能随机取的一段报文的 RTT 时间来计算超时重传
时间，TCP 保留了 RTT 的一个**加权平均往返时间 RTTS**。计算方式为。

	新的 RTTS = （1 - ∂) × (旧的 RTTS) + ∂ × (新的 RTT 样本)

这里的 0 ≤ ∂ < 1，RFC2988 推荐 ∂ 的值为 1/8。

超时重传的时间为 **RTO** 应略大于加权平均的往返时间 RTTS，RFC2988建议计算公式如下：

	RTO = RTTS + 4 × RTTD

这里的 RTTD 是 RTT 的偏差加权平均值。计算方法与旧的 RTTD、RTTS、已经新的 RTT 相关。这里就不列了。

我们知道发出一个报文，如果重传时间到了，还没有收到确认。于是会重传这段报文。过了一段时间，收到了报文的确认。那么现在问题来了，由于对同一段报文的确认信息是固定的那么：**如何判定此确认报文是先发送报文的确认，还是后发送报文的确认？**

这个判定对加权平均 RTTS 值的确认关系很大。

Karm 提出了一个算法：计算加权平均 RTTS 时，只要报文重传了，就不采用其往返时间样本。这样得出的加权平均 RTTS 和 RTO 就比较准确。

但是如果选择丢弃重传的样本，超时重传的时间就无法更新，显然如果出现了高丢包率，设置超时时间应该要提高的。

最终的解决方法是：报文没重传一次，就把超时重传的 RTO 时间增大，典型的做法是新的重传时间为 2 倍的旧的重传时间。计算 RTTS 时仍然不采用。


## 握手缺陷

#### 为什么需要三次握手？

客户端发送请求报文 M 到服务端，由于网络延迟比较严重，造成了请求超时，而后客户端又重发了一个请求报文 N 到服务端，接着是三次正常的握手建立连接，数据传输完毕，并释放连接。但是请求报文 A 这时经过一段时间延迟到达了服务端，这本是一个失效的报文，如果服务端收到该报文就立马给予客户端一个确认并建立连接，那么服务端会一直等待着客户端发数据，占用网络资源。然而实际上客户端此时并不想建立连接，所以需要客户端第三次的确认才建立连接。 


#### 缺陷引起的 SYN Flood

** 攻击 **

SYN-Flood 攻击是当前网络最为常见的 DDoS 攻击，也是最为经典的拒绝服务攻击，它就是利用了 TCP 协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户访问。

攻击者首先伪造地址对服务器发起 SYN 请求，服务器回应（SYN + ACK）包，而真实的 IP 会认为，我没有发送请求，不作回应。服务器没有收到回应，这样的话，服务器就不知道（SYN + ACK）是否发送成功，默认情况下会重试五次，这对于服务器的内存，带宽都有很大的消耗。攻击者如果处于公网，也可以伪造 IP 的话，对于服务器很难根据 IP 来判断攻击者，给防护带来很大的困难。

** SYN-Flood 防护措施 **

主要通过以下三种方式
1. 无效连接监视释放
这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。这种绝对公平的方法往往也将正常的连接的请求也会释放掉，伤敌一千，自损八百。

2. 延缓 TCB 分配方法
SYN Flood 关键是利用SYN数据报文一到，系统立即分配 TCB 资源，从而占用了系统资源，因此有两种技术来解决这一问题

- Syn Cache 技术
这种技术在收到 SYN 时不急着去分配 TCB，而是先回应一个 ACK 报文，并在一个专属的 HASH 表中保存这种半开连接，直到收到正确的 ACK 报文再去分配 TCB。

- Syn Cookie 技术
Syn Cookie 技术则完全不适用任何存储资源，它使用一种特殊的算法生成 Sequence Number，这种算法考虑到对方 IP、端口、己方 IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如 MSS、时间等，在收到对方的 ACK 报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配 TCB 资源。

3. 使用 SYN Proxy 防火墙
对试图穿越的 SYN 请求进行验证之后才放行。


摘自：《计算机网络》